Ecco un quiz di 20 domande a scelta multipla sulla memoria virtuale, con particolare attenzione ai dettagli e ai concetti chiave, formulato per stimolare la riflessione e l'analisi:

1.  In un sistema di memoria virtuale, quale tra le seguenti affermazioni descrive meglio lo scopo principale della memoria virtuale?
    *   (a) Ridurre la frammentazione esterna della memoria primaria, consentendo allocazioni più efficienti di spazio contiguo.
    *   (b) Permettere l'esecuzione di processi che richiedono più spazio di indirizzamento logico rispetto alla dimensione fisica della memoria primaria.
    *   (c) Aumentare la velocità di accesso ai dati, tramite l'utilizzo di una memoria cache ad alta velocità tra la CPU e la RAM.
    *   (d) Ottimizzare la gestione della memoria secondaria, memorizzando in modo efficiente i dati e migliorando il tempo di accesso al disco.

2.  Quale tra le seguenti situazioni potrebbe indicare la necessità di utilizzare la paginazione su richiesta (demand paging) in un sistema di gestione della memoria?
    *   (a) Un programma sta per essere eseguito, e tutte le pagine del programma sono state caricate in memoria primaria prima dell'avvio dell'esecuzione.
    *  (b) Un processo ha appena generato un indirizzo logico, ma la pagina corrispondente non è presente in memoria primaria, e deve essere caricata.
    *   (c) La CPU sta processando un'istruzione di I/O, e il sistema operativo deve allocare spazio in memoria primaria per i dati in arrivo dal dispositivo.
    *   (d) Una pagina di un processo è stata rimossa dalla memoria primaria a causa di un algoritmo di sostituzione, e il processo non vi farà più riferimento.

3.  Cosa succede quando si verifica un page fault in un sistema con paginazione su richiesta?
    *   (a) Il processo viene terminato immediatamente dal sistema operativo, per evitare l'uso di risorse di memoria non allocate.
    *   (b) La CPU continua l'esecuzione, attendendo che la pagina mancante venga caricata da una memoria secondaria.
    *   (c) Il processo viene sospeso, la pagina mancante viene caricata in memoria primaria, e il processo viene riavviato dall'istruzione che ha causato il fault.
    *   (d) Il sistema operativo genera un errore di protezione e blocca il tentativo di accesso alla pagina mancante.

4.  Quale tra le seguenti affermazioni descrive correttamente la funzione del bit di validità associato ad ogni entry della tabella delle pagine?
    *   (a) Indica se la pagina associata è stata modificata dall'ultima volta in cui è stata caricata in memoria primaria.
    *   (b) Specifica se la pagina associata è stata appena caricata dalla memoria secondaria o se era già in RAM.
    *   (c) Determina se la pagina associata è attualmente in memoria primaria o se si trova in memoria secondaria.
    *   (d) Definisce la priorità di una pagina nella memoria principale, e indica se deve essere rimossa per prima in caso di necessità.

5.  Considerando la formula eat = [(1-p) × ma] + [p× tempo di gestione del page fault], qual è l'impatto di un aumento della probabilità di page fault (p) sul tempo effettivo di accesso alla memoria (eat)?
    *   (a) Un aumento di p diminuisce il tempo effettivo di accesso alla memoria, poiche meno pagine devono essere recuperate dalla memoria secondaria.
    *   (b) Un aumento di p non ha effetto sul tempo effettivo di accesso alla memoria, poichè l'impatto del page fault è trascurabile.
    *   (c) Un aumento di p incrementa il tempo effettivo di accesso alla memoria, poichè vengono introdotti numerosi ritardi per gestire i page fault.
    *   (d) Un aumento di p diminuisce il tempo effettivo di accesso alla memoria, ma solo se il tempo di gestione del page fault è inferiore al tempo di accesso in memoria principale.

6.  Qual è il ruolo principale dell'area di swap in un sistema di memoria virtuale?
    *   (a) Memorizzare temporaneamente le pagine dei processi in attesa di esecuzione, incrementando la velocità di avvio dei processi.
    *   (b) Servire come una cache di memoria ad alta velocità per i dati più frequentemente usati, riducendo l'accesso alla memoria primaria.
    *   (c) Conservare le pagine dei processi che sono state rimosse dalla memoria primaria per liberare spazio a nuove pagine o a pagine necessarie in quel momento, e permettere di recuperarle in caso di necessità.
    *   (d) Gestire la comunicazione con la CPU, memorizzando le istruzioni in attesa di essere eseguite, e coordinando i processi in coda di Ready.

7.  Qual è una possibile conseguenza di avere un'area di swap troppo piccola rispetto alle esigenze del sistema di memoria virtuale?
    *   (a) Una diminuzione del numero di page fault, poichè lo spazio in memoria secondaria non è sufficiente a contenere le pagine che possono generare un page fault.
    *   (b) Un aumento del tempo di accesso alla memoria primaria, poichè il sistema impiega più tempo per scrivere le pagine in un'area di swap sovraffollata.
    *   (c) Un'alta probabilità di thrashing, poichè il sistema non riesce a gestire le pagine che devono essere spostate dalla memoria primaria a quella secondaria, e viceversa.
    *  (d) Nessuna conseguenza significativa, poichè la memoria virtuale è indipendente dalle dimensioni dell'area di swap, e gestisce in modo efficiente lo spazio disponibile.

8.  Quando una pagina vittima deve essere salvata nell'area di swap?
    *  (a) Quando la pagina è stata acceduta solo in lettura, per preservare le modifiche originali in memoria secondaria.
    *  (b) Quando la pagina non è stata modificata da quando è stata caricata in memoria primaria, per non sprecare tempo di scrittura.
    *   (c) Quando la pagina è stata modificata in memoria primaria e non è stata copiata in memoria secondaria, oppure fa parte dello stack o della heap di un processo.
    *   (d) Quando si deve liberare spazio per caricare una nuova pagina, indipendentemente dal fatto che la pagina sia stata modificata o meno.

9.  Qual è la funzione del "dirty bit" associato a ciascuna entry della tabella delle pagine?
    *   (a) Indica se la pagina associata è stata appena caricata dalla memoria secondaria.
    *   (b) Serve come una specie di "semaforo" che indica la priorità di una pagina nella memoria principale.
    *   (c) Segnala se la pagina associata è stata modificata (scritta) dopo essere stata caricata in memoria primaria.
    *  (d) Indica se la pagina associata si trova in memoria principale o in memoria secondaria, consentendo un accesso più veloce.

10. Quale tra le seguenti affermazioni descrive correttamente lo scopo degli algoritmi di sostituzione delle pagine?
    *  (a) Ottimizzare il caricamento delle pagine dalla memoria secondaria alla memoria primaria, per minimizzare il tempo di attesa per l'utente.
    *   (b) Stabilire quali frame della memoria primaria devono essere liberati, e quindi quali pagine devono essere rimosse, per fare spazio a nuove pagine.
    *   (c) Organizzare le pagine all'interno della memoria primaria, per garantire un accesso più veloce a quelle più frequentemente usate.
    *   (d) Gestire le code dei processi in attesa di essere eseguiti, garantendo un utilizzo efficiente della CPU e della memoria primaria.

11. Cosa significa che un algoritmo di sostituzione delle pagine "minimizza il numero di page fault"?
    *  (a) L'algoritmo cerca di mantenere in memoria primaria le pagine più usate, in modo da ridurre il numero di volte in cui il sistema deve caricare pagine dalla memoria secondaria.
    *   (b) L'algoritmo cerca di caricare tutte le pagine necessarie all'avvio di un processo in memoria primaria, in modo da evitare page fault durante l'esecuzione.
    *   (c) L'algoritmo cerca di scaricare le pagine che non vengono usate da tempo, riducendo il carico sulla memoria primaria e sul disco.
    *   (d) L'algoritmo cerca di prevedere quali pagine saranno necessarie in futuro, caricandole in memoria in anticipo per evitare di generare page fault.

12. Qual è la principale limitazione dell'algoritmo di sostituzione delle pagine FIFO (First-In, First-Out)?
    *   (a) L'algoritmo tende a rimuovere dalla memoria primaria le pagine che sono state usate più di recente, portando ad un alto numero di page fault.
    *   (b) L'algoritmo non considera la frequenza con cui le pagine sono state usate, quindi pagine usate frequentemente potrebbero essere rimosse prematuramente, causando un aumento dei page fault.
    *   (c) L'algoritmo è difficile da implementare e richiede molte risorse, poichè non ha modo di riconoscere quando una pagina è stata caricata in memoria.
    *   (d) L'algoritmo tende a rimuovere le pagine più vecchie anche se sono quelle più utili, a causa della sua natura ciclica.

13. Cosa si intende per "anomalia di Belady" in relazione all'algoritmo FIFO?
    *   (a) Si verifica quando l'algoritmo FIFO rimuove le pagine che sono state caricate da poco, anzichè quelle più vecchie.
    *   (b) Si presenta quando l'algoritmo FIFO genera sempre lo stesso numero di page fault, indipendentemente dal numero di frame disponibili.
    *  (c) Si manifesta quando un aumento del numero di frame disponibili porta paradossalmente ad un aumento dei page fault con l'algoritmo FIFO.
    *   (d) Si ha quando l'algoritmo FIFO non riesce a liberare la memoria primaria, provocando un blocco del sistema.

14. Qual è la principale caratteristica distintiva dell'algoritmo di sostituzione delle pagine OPT (o MIN)?
    *  (a) L'algoritmo cerca di sostituire la pagina usata meno recentemente, per imitare l'algoritmo LRU.
    *  (b) L'algoritmo cerca di sostituire la pagina che non verrà più usata in futuro, garantendo un numero minimo di page fault.
    *   (c) L'algoritmo cerca di rimuovere la pagina che è stata caricata per prima, simulando una coda FIFO.
    *   (d) L'algoritmo cerca di tenere traccia delle pagine usate più spesso, e non le rimuove dalla RAM finché sono state usate.

15. Qual è la principale differenza tra l'algoritmo di sostituzione delle pagine LRU (Least Recently Used) e l'algoritmo OPT?
    *   (a) LRU guarda al futuro, mentre OPT guarda al passato per determinare quale pagina sostituire, scegliendo la pagina non usata più recentemente.
    *   (b) LRU cerca di stimare quando una pagina sarà usata di nuovo, mentre OPT sceglie la pagina da sostituire basandosi sull'uso più recente, scegliendo quella non usata più a lungo.
    *   (c) LRU sostituisce la pagina che è stata usata meno di recente, mentre OPT sostituisce la pagina che non sarà usata per più tempo nel futuro.
    *  (d) LRU non soffre dell'anomalia di Belady, mentre OPT non è un algoritmo ideale, poichè fa un uso intensivo della memoria secondaria.

16.  Qual è la funzione del "reference bit" nell'algoritmo della seconda chance, un'approssimazione dell'algoritmo LRU?
    *  (a) Indicare se una pagina è stata usata di recente (settato a 1) o meno (settato a 0), per consentire un'approssimazione della sostituzione LRU.
    *  (b) Segnalare la priorità di una pagina nella memoria principale, indicando se deve essere rimossa per prima in caso di page fault.
    *   (c) Controllare se una pagina è stata modificata dall'ultima volta che è stata caricata in memoria, aiutando a minimizzare la scrittura su disco.
    *  (d) Mantenere una cronologia degli accessi di una pagina, indicando l'ordine in cui è stata usata per ottimizzare la sostituzione delle pagine.

17. In cosa consiste il fenomeno del thrashing in un sistema di memoria virtuale?
    *   (a) Si verifica quando la CPU è sovraccarica a causa di un numero elevato di processi attivi, e il sistema non è in grado di gestire le richieste.
    *   (b) Si verifica quando il sistema operativo non riesce ad allocare frame di memoria sufficienti a tutti i processi, e la CPU deve costantemente attendere il completamento delle operazioni di I/O.
    *   (c) Si verifica quando i processi spendono più tempo a gestire i page fault che a fare il loro lavoro, con una diminuzione drastica delle prestazioni del sistema.
    *   (d) Si verifica quando la memoria secondaria è piena e il sistema non riesce più a caricare nuove pagine o a salvare quelle esistenti, bloccando il sistema.

18. Quale tra le seguenti azioni è la più efficace per mitigare il problema del thrashing?
    *   (a) Aumentare il numero di processi in esecuzione, per sfruttare al massimo le risorse del sistema ed accelerare la velocità di calcolo.
    *   (b) Diminuire temporaneamente il grado di multiprogrammazione, in modo che i processi in memoria abbiano più frame a disposizione, e meno page fault.
    *   (c) Aumentare la frequenza con cui il sistema operativo controlla la memoria primaria, in modo da individuare i page fault in anticipo, e gestirli in modo più efficiente.
    *   (d) Allocare frame di memoria uniformemente a tutti i processi, per garantire un utilizzo equo delle risorse ed evitare blocchi.

19.  In un sistema con paginazione, quali sono i vantaggi di usare pagine di grandi dimensioni?
    *  (a) Tabella delle pagine più piccole, meno frammentazione interna, più page fault, e un uso ottimale del disco.
    *   (b) Tabella delle pagine più grandi, più frammentazione interna, meno page fault, e un uso efficiente del disco.
    *  (c) Tabella delle pagine più piccole, meno frammentazione interna, meno page fault e migliori prestazioni nell'uso del disco.
    *  (d) Tabella delle pagine più grandi, più frammentazione interna, più page fault e peggiori prestazioni nell'uso del disco.

20. In che modo la struttura dei programmi influisce sul numero di page fault in un sistema di memoria virtuale?
    *   (a) L'ordine in cui i dati sono memorizzati in memoria non ha nessun impatto sul numero di page fault, poichè il sistema di memoria virtuale li gestisce in modo efficiente.
    *   (b) La disposizione dei dati e degli indirizzi nella memoria virtuale ha un impatto significativo, poichè la contiguità logica non garantisce la contiguità fisica.
    *   (c) L'ordine in cui le istruzioni sono eseguite non ha impatto, poichè i page fault sono causati principalmente dall'accesso ai dati, e non al codice del programma.
    *   (d) I page fault sono causati principalmente dall'uso intensivo del disco, e non dalla struttura dei programmi, o da come accedono ai dati.

Risposte:
1.(b) 2.(b) 3.(c) 4.(c) 5.(c) 6.(c) 7.(c) 8.(c) 9.(c) 10.(b) 11.(a) 12.(b) 13.(c) 14.(b) 15.(c) 16.(a) 17.(c) 18.(b) 19.(c) 20.(b)